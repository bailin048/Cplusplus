LeetCode【24】【两两交换链表中的节点】：https://leetcode-cn.com/problems/swap-nodes-in-pairs/
【递归法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next)
        return head;
        struct ListNode *newhead = head->next;
        head->next = swapPairs(newhead->next);
        newhead->next = head;
        return newhead;
    }
};
【迭代法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* rear = dummyHead;
        while(rear->next != nullptr && rear->next->next != nullptr ){
            ListNode *node1 = rear->next;
            ListNode *node2 = rear->next->next;
            rear->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            rear = node1;
        }
        return dummyHead->next;
    }
};

LeetCode【41】【缺失的第一个正数】：https://leetcode-cn.com/problems/first-missing-positive/
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0;i < n; i++){
            while(nums[i]>0 && nums[i]<=n && nums[nums[i]-1] != nums[i])
                swap(nums[i],nums[nums[i]-1]);
        }
        for(int i = 0;i < n; i++)
            if(nums[i]!=i+1)
                return i+1;
        return n+1;
    }
};

面试题【17.16】【按摩师】：https://leetcode-cn.com/problems/the-masseuse-lcci/
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n==0)
            return 0;
        if(n==1)
            return nums[0];
        if(n==2)
            return fmax(nums[0],nums[1]);
        int dp0 = nums[0],dp1 = fmax(nums[0],nums[1]),dp2 = 0;
        for(int i = 2;i<n;i++){
            dp2 = fmax(dp1,dp0+nums[i]);
            dp0 = dp1;
            dp1 = dp2; 
        }
        return dp2;
    }
};

面试题【16.01】【交换数字】：https://leetcode-cn.com/problems/swap-numbers-lcci/
class Solution {
public:
    vector<int> swapNumbers(vector<int>& numbers) {
        numbers[0]^=numbers[1];
        numbers[1]^=numbers[0];
        numbers[0]^=numbers[1];
        return numbers;
    }
};

面试题【17.10】【主要元素】：https://leetcode-cn.com/problems/find-majority-element-lcci/
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int sum = 0,flag = 0,i;
        for(int i=0;i<n;i++){
            if(sum<=0){
                flag = nums[i];
                ++sum;
            }
            else{
                nums[i] == flag?++sum:--sum;
            }
        }
        int cnt = 0;
        for(int  i =0;i<n;i++)
            if(flag == nums[i])
                cnt++;
        return cnt>n/2?flag:-1;
    }
};

LeetCode【961】【重复N次的元素】：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/
class Solution {
public:
    int repeatedNTimes(vector<int>& A) {
        int n = A.size(),flag = 0;
        for(int i = 1; i<n-1;++i){
            if(A[i] == A[i-1] || A[i] == A[i+1]){
                flag = i;
                break;
            }
            if(A[i-1] == A[i+1]){
                flag = i - 1;
                break;
            }
        }
        return A[flag];
    }
};



