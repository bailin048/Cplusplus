LeetCode【24】【两两交换链表中的节点】：https://leetcode-cn.com/problems/swap-nodes-in-pairs/
【递归法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next)
        return head;
        struct ListNode *newhead = head->next;
        head->next = swapPairs(newhead->next);
        newhead->next = head;
        return newhead;
    }
};
【迭代法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* rear = dummyHead;
        while(rear->next != nullptr && rear->next->next != nullptr ){
            ListNode *node1 = rear->next;
            ListNode *node2 = rear->next->next;
            rear->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            rear = node1;
        }
        return dummyHead->next;
    }
};

LeetCode【41】【缺失的第一个正数】：https://leetcode-cn.com/problems/first-missing-positive/
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0;i < n; i++){
            while(nums[i]>0 && nums[i]<=n && nums[nums[i]-1] != nums[i])
                swap(nums[i],nums[nums[i]-1]);
        }
        for(int i = 0;i < n; i++)
            if(nums[i]!=i+1)
                return i+1;
        return n+1;
    }
};

面试题【17.16】【按摩师】：https://leetcode-cn.com/problems/the-masseuse-lcci/
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n==0)
            return 0;
        if(n==1)
            return nums[0];
        if(n==2)
            return fmax(nums[0],nums[1]);
        int dp0 = nums[0],dp1 = fmax(nums[0],nums[1]),dp2 = 0;
        for(int i = 2;i<n;i++){
            dp2 = fmax(dp1,dp0+nums[i]);
            dp0 = dp1;
            dp1 = dp2; 
        }
        return dp2;
    }
};

面试题【16.01】【交换数字】：https://leetcode-cn.com/problems/swap-numbers-lcci/
class Solution {
public:
    vector<int> swapNumbers(vector<int>& numbers) {
        numbers[0]^=numbers[1];
        numbers[1]^=numbers[0];
        numbers[0]^=numbers[1];
        return numbers;
    }
};

面试题【17.10】【主要元素】：https://leetcode-cn.com/problems/find-majority-element-lcci/
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int sum = 0,flag = 0,i;
        for(int i=0;i<n;i++){
            if(sum<=0){
                flag = nums[i];
                ++sum;
            }
            else{
                nums[i] == flag?++sum:--sum;
            }
        }
        int cnt = 0;
        for(int  i =0;i<n;i++)
            if(flag == nums[i])
                cnt++;
        return cnt>n/2?flag:-1;
    }
};

LeetCode【961】【重复N次的元素】：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/
class Solution {
public:
    int repeatedNTimes(vector<int>& A) {
        int n = A.size(),flag = 0;
        for(int i = 1; i<n-1;++i){
            if(A[i] == A[i-1] || A[i] == A[i+1]){
                flag = i;
                break;
            }
            if(A[i-1] == A[i+1]){
                flag = i - 1;
                break;
            }
        }
        return A[flag];
    }
};

剑指offer【43】【1~n整数中1出现的次数】：https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/
class Solution {
public:
    int countDigitOne(int n) {
         int count = 0;
    long digit = 1;
    int cur=n%10,high = n/10,low = 0;
    while(high != 0 || cur != 0){
        if(cur == 0)
            count += high*digit;
        else if(cur == 1)
            count += high*digit+low+1;
        else
            count += (high+1)*digit;
        low += cur*digit;
        cur = high % 10;
        high/=10;
        digit *= 10;
    }
    return count;
    }
};

剑指offer【54】【二叉搜索树的第k大的节点】：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/
public:
    void NumofNode(TreeNode* root,int *n){
        if(!root)
            return;
        (*n)++;
        NumofNode(root->left,n);
        NumofNode(root->right,n);
        return; 
    }
    void midorder(TreeNode* root,int *arg,int* index){
        if(!root)
            return;
        midorder(root->left,arg,index);
        arg[*index] = root->val;
        (*index)++;
        midorder(root->right,arg,index);
        return;
    }
    int kthLargest(TreeNode* root, int k) {
        int n = 0;
        NumofNode(root,&n);
        int* arg = (int*)malloc(sizeof(int)*n);
        int index = 0;
        midorder(root,arg,&index);
        return arg[n-k];
    }
};

剑指offer【63】【股票的最大利润】：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(!n)
            return 0;
        int buy = prices[0];
        int Max = 0;
        int* profit = (int*)malloc(sizeof(int)*n);
        for(int i = 1; i < n; i++){
            buy = prices[i]<buy?prices[i]:buy;
            profit[i] = prices[i]-buy;
            Max = Max < profit[i]?profit[i]:Max;
        }
        return Max;
    }
};

LeetCode【129】【求根节点到叶节点数字之和】：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/
class Solution {
public:
    void NumofLeaf(TreeNode* root,int* count){
        if(!root)
            return;
        if((!root->left) && (!root->right))
            (*count)++;
        NumofLeaf(root->left,count);
        NumofLeaf(root->right,count);
        return;
    }
    void helper(TreeNode* root,int* tmp,int* index, int num){
        if(!root)
            return;
        if((!root->left) && (!root->right)){
            tmp[(*index)] = num*10+root->val;
            (*index)++;
        }
        num = num*10 + root->val;
        helper(root->left,tmp,index,num);
        helper(root->right,tmp,index,num);
        return;
    }
    int sumNumbers(TreeNode* root) {
        int count = 0;
        NumofLeaf(root,&count);
        int* tmp = (int*)malloc(sizeof(int)*count);
        int index = 0;
        helper(root,tmp,&index,0);
        int sum = 0;
        for(int  i = 0;i<index;i++)
            sum+=tmp[i];
        return sum;
    }
};

LeetCode【222】【完全二叉树的节点个数】：https://leetcode-cn.com/problems/count-complete-tree-nodes/
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root)
            return 0;
        return countNodes(root->left)+countNodes(root->right)+1;
    }
};

LeetCode【543】【二叉树的直径】：https://leetcode-cn.com/problems/diameter-of-binary-tree/
class Solution {
public:
    int helper(TreeNode* root,int& ans){
        if(!root)
            return 0;
        int l = helper(root->left,ans);
        int r = helper(root->right,ans);
        ans = max(l + r, ans);
        return max(l, r) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int length = 0;
        helper(root,length);
        return length;
    }
};

剑指offer【64】【求1+2+3+……+n】：https://leetcode-cn.com/problems/qiu-12n-lcof/
class Solution {
public:
    int sumNums(int n) {
        int res = 0;
        for(int  i = 0;i<14;i++)//将n+1拆分为2的幂和
        {
            int tmp = (n&-((n+1)>>i&1))<<i;
            res += tmp;
        }
        return res>>1;
    }
};

牛客【计算日期到天数转换】：https://www.nowcoder.com/practice/769d45d455fe40b385ba32f97e7bcded?tpId=37&tqId=21296&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fhuawei%2Fquestion-ranking&tab=answerKey
#include <iostream>
using namespace std;

int OrderofDay(int year,int month,int day){
    int res = 0 , _month = 1;
    int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
    bool flag = false;
    if(year%400==0 || (year%4==0 && year%100!=0))
        flag = true;
    if(year<1 || month<1 ||  month>12 || day<1 || day>31 || 
       (flag && month == 2 && day>29) || ((!flag) && month == 2 && day>28))
            return -1;
    while(_month && _month<month){
        res += days[_month];
        if(flag && _month==2)
            ++res;
        ++_month;
    }
    return res + day;
}
int main(){
    int y,m,d;
    while(cin>>y>>m>>d)
        cout<<OrderofDay(y, m, d)<<endl;
    return 0;
}

牛客【日期累加】：https://www.nowcoder.com/practice/eebb2983b7bf40408a1360efb33f9e5d?tpId=40&tqId=31013&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fkaoyan%2Fquestion-ranking&tab=answerKey
#include <iostream>
#include <stdio.h>
using namespace std;
bool IsLeapYear(int y){
    if(y%400==0 || (y%4==0 && y%100!=0))
        return true;
    return false;
}
int GetDayofMonth(int year,int month){
    int _days[13]={29,31,28,31,30,31,30,31,31,30,31,30,31};
    bool flag = IsLeapYear(year);
    if(flag && month == 2)
        return _days[0];
    return _days[month];
}
void DateAddDay(int y,int m,int d,int day){
    d += day;
    while(d > GetDayofMonth(y,m)){
        d-=GetDayofMonth(y,m);
        ++m;
        if(m == 13)
            ++y,m=1;
    }
    printf("%04d-%02d-%02d\n",y,m,d);
}
int main(){
    int group = 0;
    cin>>group;
    int y,m,d,day;
    for(int i = 0;i<group;i++){
        cin>>y>>m>>d>>day;
        DateAddDay(y, m,d,day);
    }
    return 0;
}

牛客【打印日期】：https://www.nowcoder.com/practice/b1f7a77416194fd3abd63737cdfcf82b?tpId=69&tqId=29669&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fhust-kaoyan%2Fquestion-ranking&tab=answerKey
#include <iostream>
using namespace std;
bool IsLeapYear(int y){
    if(y%400==0 || (y%4==0 && y%100!=0))
        return true;
    return false;
}
int GetDayofMonth(int year,int month){
    int _days[13]={29,31,28,31,30,31,30,31,31,30,31,30,31};
    bool flag = IsLeapYear(year);
    if(flag && month == 2)
        return _days[0];
    return _days[month];
}
void PrintDate(int year,int day){
    int month = 1;
    while(day>GetDayofMonth(year, month)){
        day -= GetDayofMonth(year, month);
        ++month;
        if(month == 13)
            month = 1,++year;
    }
    printf("%04d-%02d-%02d\n",year,month,day);
}
int main(){
    int year,day;
    while(cin>>year>>day)
        PrintDate(year,day);
    return 0;
}

牛客【日期差值】：https://www.nowcoder.com/practice/ccb7383c76fc48d2bbc27a2a6319631c?tpId=62&tqId=29468&rp=1&ru=&tab=answerKey
#include <iostream>
using namespace std;
bool IsLeapYear(int year);
namespace Days {//申请13个的目的：月份=索引
    int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31 };
};

using namespace Days;
class Date
{
    friend bool IsLeapYear(int year);
public:
    int GetMonthDay(int year, int month) {
        bool  flag = IsLeapYear(year);
        return (flag&& month==2)?days[month]+1:days[month];//闰年2月+1天
    }
    void DateShow() {
        cout << _year << "年" << _month << "月" << _day << "日" << endl;
    }
    Date(int year = 1900, int month = 1, int day = 1) {    //全缺省默认构造函数
        _year = year;
        _month = month;
        _day = day;
    }
    Date(const Date &t) {// 拷贝构造函数
        _year = t._year;
        _month = t._month;
        _day = t._day;
    }
    Date& operator=(const Date& d) {//赋值运算符重载
        if (this != &d) {
            _year = d._year;
            _month = d._month;
            _day = d._day;
        }
        return *this;
    }
    ~Date() {}
    Date& operator+=(int day) {
        *this = *this + day;
        return *this;
    }
    Date operator+(int day) {
        Date p(*this);
        if (day < 0) {
            p -= -day;
            return p;
        }
        p._day += day;
        while (p._day > GetMonthDay(p._year, p._month)) {
            p._day -= GetMonthDay(p._year, p._month);
            ++p._month;
            if (p._month == 13) {
                p._month = 1;
                ++p._year;
            }
        }
        return p;
    }
    Date operator-(int day) {
        Date p(*this);//新对象
        if (day < 0) {
            p += -day;
            return p;
        }
        p._day -= day;
        int month = 0;
        while (p._day <= 0) {
            month = p._month == 1 ? 12 : p._month - 1;//月份为1则减到上一年12月
            p._day += GetMonthDay(p._year, month);//加上上一月天数
            --p._month;//月份倒退
            if (p._month == 0) {//年份倒退
                p._month = 12;
                --p._year;
            }
        }
        return p;
    }
    Date& operator-=(int day) {
        *this = *this - day;
        return *this;
    }
    Date& operator++() {
        *this = *this + 1;
        return *this;
    }
    Date operator++(int) {
        Date tmp(*this);
        *this += 1;
        return tmp;
    }
    Date operator--(int) {
        Date tmp(*this);
        *this -= 1;
        return tmp;
    }
    Date& operator--() {
        *this -= 1;
        return *this;
    }
    bool operator>(const Date& d) {
        if (d._year > (*this)._year)
            return false;
        if (d._year < (*this)._year)
            return true;
        if (d._month > (*this)._month)//到达此处，说明年份一样
            return false;
        if (d._month < (*this)._month)
            return true;
        if (d._day > (*this)._day)//达到此处，说明月份一样
            return false;
        if (d._day < (*this)._day)
            return true;
        return true;
    }
    bool operator==(const Date& d) {
        return d._year == (*this)._year &&
            d._month == (*this)._month &&
            d._day == (*this)._day;
    }
    inline bool operator >= (const Date& d) {
        return *this > d || *this == d;
    }
    bool operator < (const Date& d) {
        return !(*this >= d);//<的互斥函数为>=
    }
    bool operator <= (const Date& d) {
        return !(*this > d);//<= 的互斥事件为>
    }
    bool operator != (const Date& d) {
        return !((*this) == d);//!= 的互斥事件为 ==
    }
    int operator-(const Date& d) {
        Date Min;
        Date Max;
        *this < d ? (Max = d, Min = *this) :(Max = *this, Min = d);
        int res = 0;
        while (Min < Max)
            ++res, ++Min;
        return ++res;
    }
private:
    int _year;
    int _month;
    int _day;
};
bool IsLeapYear(int year) {
    if (year % 4 == 0 && year % 100 != 0)//普通闰年
        return true;
    if (year % 400 == 0)//世纪闰年
        return true;
    return false;
}
int main(){
    int data1,data2;
    int y1,y2,m1,m2,d1,d2;
    while(cin>>data1,cin>>data2){
        d1 = data1%100,d2 = data2%100;
        m1 = data1/100%100,m2 = data2/100%100;
        y1 = data1/10000,y2 = data2/10000;
        Date D1(y1,m1,d1);
        Date D2(y2,m2,d2);
        cout<<D2-D1<<endl;
    }
}

LeetCode【230】【二叉搜索树中第K小的元素】：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/
class Solution {
public:
    void helper(TreeNode* root,int k,int* res,int* index){
        if(!root)
            return;
        helper(root->left,k,res,index);
        (*index)++;
        if(*index == k)
            *res = root->val;
        helper(root->right,k,res,index);
        return;
    } 
    int kthSmallest(TreeNode* root, int k) {
        int res = INT_MIN;
        int index = 0; 
        helper(root,k,&res,&index);
        return res;
    }
};

LeetCode【671】【二叉树中第二小的节点】：https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/
class Solution {
public:
    void helper(TreeNode* root,int* tmp,int* index){
        if(!root)
            return;
        helper(root->left,tmp,index);
        tmp[*index] = root->val;
        (*index)++;
        helper(root->right,tmp,index);
    }
    int findSecondMinimumValue(TreeNode* root) {
        int* tmp = new int[25];
        int index = 0;
        int res = -1;
        helper(root,tmp,&index);
        int dk = index;
        while(dk/=2){
            for(int i = dk;i<index;i++){
                if(tmp[i-dk]>tmp[i]){
                    int n = tmp[i],j;
                    for(j = i-dk;j>-1&&tmp[j]>n;j-=dk)
                        tmp[j+dk] = tmp[j];
                    tmp[j+dk] = n;
                }
            }
        }
        for(int i = 0;i<index;i++)
            if(tmp[i]!=root->val){
                res = tmp[i];
                break;
            }
        delete []tmp;
        return res;
    }
};

LeetCode【108】【将有序数组转换为二叉搜索树】：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/
class Solution {
public:
    TreeNode* helper(vector<int>& nums, int left, int right){
        if(left>right)
            return nullptr;
        int mid = left + (right-left)/2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = helper(nums, left, mid-1);
        root->right = helper(nums, mid+1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums, 0,nums.size()-1);
    }
};

LeetCode【700】【二叉搜索树中的搜索】：https://leetcode-cn.com/problems/search-in-a-binary-search-tree/
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root || root->val ==    val)
            return root;
        return  val < root->val ? searchBST(root->left, val) : searchBST(root->right, val);
    }
};

LeetCode【653】【两数之和IV-输入BST】：https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/
class Solution {
public:
    void helper(TreeNode* root,int* res,int* index){
        if(!root)
            return;
        helper(root->left,res,index);
        res[*index] = root->val;
        (*index)++;
        helper(root->right,res,index);
    } 
    bool findTarget(TreeNode* root, int k) {
        int* res = new int[10000];
        int index = 0;
        helper(root,res,&index);
        int left = 0,right = index - 1;
        while(left<right){
            if(res[left] + res[right] > k)
                --right;
            else if(res[left] + res[right] < k)
                ++left;
            else
                return true;
        }
        return false;
    }
};

LeetCode【563】【二叉树的坡度】：https://leetcode-cn.com/problems/binary-tree-tilt/
class Solution {
public:
    int res = 0;
    int helper(TreeNode* root){
        if(!root)
            return 0;
        int left = helper(root->left);
        int right = helper(root->right);
        res += fabs(left-right);
        return left + right + root->val;
    } 
    int findTilt(TreeNode* root) {
        helper(root);
        return res;
    }
};

剑指offer【31】【栈的压入、弹出序列】：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/
bool validateStackSequences(int* pushed, int pushedSize, int* popped, int poppedSize){
    int* stack = (int*)malloc(sizeof(int)*poppedSize);
    int top = -1;
    int index = 0;
    for(int i = 0;i<pushedSize;i++){
        stack[++top] = pushed[i];
        while(top!=-1 && stack[top]==popped[index])
            --top,++index;
    }
    return top == -1;
}