LeetCode【24】【两两交换链表中的节点】：https://leetcode-cn.com/problems/swap-nodes-in-pairs/
【递归法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next)
        return head;
        struct ListNode *newhead = head->next;
        head->next = swapPairs(newhead->next);
        newhead->next = head;
        return newhead;
    }
};
【迭代法】
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* rear = dummyHead;
        while(rear->next != nullptr && rear->next->next != nullptr ){
            ListNode *node1 = rear->next;
            ListNode *node2 = rear->next->next;
            rear->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            rear = node1;
        }
        return dummyHead->next;
    }
};

LeetCode【41】【缺失的第一个正数】：https://leetcode-cn.com/problems/first-missing-positive/
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0;i < n; i++){
            while(nums[i]>0 && nums[i]<=n && nums[nums[i]-1] != nums[i])
                swap(nums[i],nums[nums[i]-1]);
        }
        for(int i = 0;i < n; i++)
            if(nums[i]!=i+1)
                return i+1;
        return n+1;
    }
};

面试题【17.16】【按摩师】：https://leetcode-cn.com/problems/the-masseuse-lcci/
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n==0)
            return 0;
        if(n==1)
            return nums[0];
        if(n==2)
            return fmax(nums[0],nums[1]);
        int dp0 = nums[0],dp1 = fmax(nums[0],nums[1]),dp2 = 0;
        for(int i = 2;i<n;i++){
            dp2 = fmax(dp1,dp0+nums[i]);
            dp0 = dp1;
            dp1 = dp2; 
        }
        return dp2;
    }
};

面试题【16.01】【交换数字】：https://leetcode-cn.com/problems/swap-numbers-lcci/
class Solution {
public:
    vector<int> swapNumbers(vector<int>& numbers) {
        numbers[0]^=numbers[1];
        numbers[1]^=numbers[0];
        numbers[0]^=numbers[1];
        return numbers;
    }
};

面试题【17.10】【主要元素】：https://leetcode-cn.com/problems/find-majority-element-lcci/
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        int sum = 0,flag = 0,i;
        for(int i=0;i<n;i++){
            if(sum<=0){
                flag = nums[i];
                ++sum;
            }
            else{
                nums[i] == flag?++sum:--sum;
            }
        }
        int cnt = 0;
        for(int  i =0;i<n;i++)
            if(flag == nums[i])
                cnt++;
        return cnt>n/2?flag:-1;
    }
};

LeetCode【961】【重复N次的元素】：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/
class Solution {
public:
    int repeatedNTimes(vector<int>& A) {
        int n = A.size(),flag = 0;
        for(int i = 1; i<n-1;++i){
            if(A[i] == A[i-1] || A[i] == A[i+1]){
                flag = i;
                break;
            }
            if(A[i-1] == A[i+1]){
                flag = i - 1;
                break;
            }
        }
        return A[flag];
    }
};

剑指offer【43】【1~n整数中1出现的次数】：https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/
class Solution {
public:
    int countDigitOne(int n) {
         int count = 0;
    long digit = 1;
    int cur=n%10,high = n/10,low = 0;
    while(high != 0 || cur != 0){
        if(cur == 0)
            count += high*digit;
        else if(cur == 1)
            count += high*digit+low+1;
        else
            count += (high+1)*digit;
        low += cur*digit;
        cur = high % 10;
        high/=10;
        digit *= 10;
    }
    return count;
    }
};

剑指offer【54】【二叉搜索树的第k大的节点】：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/
public:
    void NumofNode(TreeNode* root,int *n){
        if(!root)
            return;
        (*n)++;
        NumofNode(root->left,n);
        NumofNode(root->right,n);
        return; 
    }
    void midorder(TreeNode* root,int *arg,int* index){
        if(!root)
            return;
        midorder(root->left,arg,index);
        arg[*index] = root->val;
        (*index)++;
        midorder(root->right,arg,index);
        return;
    }
    int kthLargest(TreeNode* root, int k) {
        int n = 0;
        NumofNode(root,&n);
        int* arg = (int*)malloc(sizeof(int)*n);
        int index = 0;
        midorder(root,arg,&index);
        return arg[n-k];
    }
};

剑指offer【63】【股票的最大利润】：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(!n)
            return 0;
        int buy = prices[0];
        int Max = 0;
        int* profit = (int*)malloc(sizeof(int)*n);
        for(int i = 1; i < n; i++){
            buy = prices[i]<buy?prices[i]:buy;
            profit[i] = prices[i]-buy;
            Max = Max < profit[i]?profit[i]:Max;
        }
        return Max;
    }
};


